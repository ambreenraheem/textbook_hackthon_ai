---
id: project-01-ros2-robot
title: Project 1 - Basic ROS 2 Robot
description: Build and simulate a basic mobile robot using ROS 2, implementing navigation and sensor integration.
sidebar_label: Proj 1. Basic ROS 2 Robot
sidebar_position: 1
difficulty: beginner
estimatedDuration: 2-4 hours
prerequisites:
  - ch05-intro-ros2
  - ch06-ros2-concepts
  - ch07-communication-patterns
  - ch09-gazebo
technologies: [ROS 2 Jazzy, Gazebo, Python, URDF]
learningOutcomes:
  - Set up a ROS 2 development environment
  - Create a simple mobile robot model
  - Implement basic navigation algorithms
  - Integrate simulated sensors (LiDAR, IMU)
keywords: [ROS 2, mobile robot, navigation, Gazebo, URDF]
---

# Project 1: Basic ROS 2 Robot

## Overview

In this project, you'll build a complete mobile robot simulation using ROS 2 and Gazebo. You'll create a robot model, implement basic navigation, and integrate sensors for autonomous operation.

## Prerequisites

Before starting this project, you should have completed:
- [Chapter 5: Introduction to ROS 2](/docs/part-02-ros2/ch05-intro-ros2) - ROS 2 setup and basics
- [Chapter 6: ROS 2 Concepts](/docs/part-02-ros2/ch06-ros2-concepts) - Nodes, topics, and services
- [Chapter 7: Communication Patterns](/docs/part-02-ros2/ch07-communication-patterns) - Publisher-subscriber patterns
- [Chapter 9: Gazebo Simulation](/docs/part-03-simulation/ch09-gazebo) - Robot simulation fundamentals

## Learning Objectives

By completing this project, you will:
1. Set up a ROS 2 development workspace
2. Create a URDF model for a differential drive robot
3. Launch a Gazebo simulation environment
4. Implement teleoperation control
5. Add LiDAR and IMU sensors to your robot
6. Develop a simple obstacle avoidance algorithm
7. Visualize sensor data in RViz2

## Project Steps

### Step 1: Environment Setup

#### 1.1 Install ROS 2 Jazzy

Follow the official installation guide for your platform:

```bash
# Ubuntu 24.04 (Noble)
sudo apt update && sudo apt install -y software-properties-common
sudo add-apt-repository universe
sudo apt update && sudo apt install curl -y
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

sudo apt update
sudo apt install ros-jazzy-desktop -y
```

#### 1.2 Set Up Workspace

```bash
# Source ROS 2
echo "source /opt/ros/jazzy/setup.bash" >> ~/.bashrc
source ~/.bashrc

# Install development tools
sudo apt install -y python3-colcon-common-extensions python3-rosdep

# Initialize rosdep
sudo rosdep init
rosdep update

# Create workspace
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
colcon build
echo "source ~/ros2_ws/install/setup.bash" >> ~/.bashrc
```

#### 1.3 Install Gazebo and Required Packages

```bash
# Install Gazebo Harmonic
sudo apt install -y ros-jazzy-gazebo-ros-pkgs
sudo apt install -y ros-jazzy-ros-gz

# Install navigation and visualization tools
sudo apt install -y ros-jazzy-navigation2 ros-jazzy-nav2-bringup
sudo apt install -y ros-jazzy-rviz2
sudo apt install -y ros-jazzy-robot-state-publisher
sudo apt install -y ros-jazzy-joint-state-publisher
```

#### 1.4 Verify Installation

```bash
# Test Gazebo
gz sim

# Test ROS 2 (in new terminal)
ros2 run demo_nodes_cpp talker
# In another terminal
ros2 run demo_nodes_cpp listener
```

---

### Step 2: Robot Model Creation

#### 2.1 Create Robot Package

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_cmake my_robot \
  --dependencies rclcpp std_msgs sensor_msgs geometry_msgs \
  --node-name robot_controller

cd my_robot
mkdir -p urdf launch config worlds
```

#### 2.2 Define Robot URDF

Create `urdf/my_robot.urdf.xacro`:

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="my_robot">

  <!-- Properties -->
  <xacro:property name="wheel_radius" value="0.05"/>
  <xacro:property name="wheel_width" value="0.04"/>
  <xacro:property name="wheel_separation" value="0.3"/>
  <xacro:property name="base_length" value="0.4"/>
  <xacro:property name="base_width" value="0.3"/>
  <xacro:property name="base_height" value="0.15"/>

  <!-- Base Link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="${base_length} ${base_width} ${base_height}"/>
      </geometry>
      <material name="blue">
        <color rgba="0.0 0.0 0.8 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="${base_length} ${base_width} ${base_height}"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.0395833" ixy="0.0" ixz="0.0"
               iyy="0.0604167" iyz="0.0" izz="0.075"/>
    </inertial>
  </link>

  <!-- Wheel Macro -->
  <xacro:macro name="wheel" params="prefix reflect">
    <link name="${prefix}_wheel">
      <visual>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
        </geometry>
        <material name="black">
          <color rgba="0.0 0.0 0.0 1.0"/>
        </material>
        <origin xyz="0 0 0" rpy="${pi/2} 0 0"/>
      </visual>
      <collision>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
        </geometry>
        <origin xyz="0 0 0" rpy="${pi/2} 0 0"/>
      </collision>
      <inertial>
        <mass value="0.5"/>
        <inertia ixx="0.000354" ixy="0.0" ixz="0.0"
                 iyy="0.000354" iyz="0.0" izz="0.000625"/>
      </inertial>
    </link>

    <joint name="${prefix}_wheel_joint" type="continuous">
      <parent link="base_link"/>
      <child link="${prefix}_wheel"/>
      <origin xyz="0 ${reflect * wheel_separation/2} 0" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
    </joint>
  </xacro:macro>

  <!-- Instantiate Wheels -->
  <xacro:wheel prefix="left" reflect="1"/>
  <xacro:wheel prefix="right" reflect="-1"/>

  <!-- Caster Wheel -->
  <link name="caster_wheel">
    <visual>
      <geometry>
        <sphere radius="0.025"/>
      </geometry>
      <material name="gray">
        <color rgba="0.5 0.5 0.5 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <sphere radius="0.025"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="0.0000625" ixy="0.0" ixz="0.0"
               iyy="0.0000625" iyz="0.0" izz="0.0000625"/>
    </inertial>
  </link>

  <joint name="caster_wheel_joint" type="fixed">
    <parent link="base_link"/>
    <child link="caster_wheel"/>
    <origin xyz="-0.15 0 -0.1" rpy="0 0 0"/>
  </joint>

  <!-- Gazebo Differential Drive Plugin -->
  <gazebo>
    <plugin filename="gz-sim-diff-drive-system" name="gz::sim::systems::DiffDrive">
      <left_joint>left_wheel_joint</left_joint>
      <right_joint>right_wheel_joint</right_joint>
      <wheel_separation>${wheel_separation}</wheel_separation>
      <wheel_radius>${wheel_radius}</wheel_radius>
      <odom_publish_frequency>50</odom_publish_frequency>
      <topic>/cmd_vel</topic>
      <odom_topic>/odom</odom_topic>
      <frame_id>odom</frame_id>
      <child_frame_id>base_link</child_frame_id>
    </plugin>
  </gazebo>

</robot>
```

#### 2.3 Create Launch File

Create `launch/robot.launch.py`:

```python
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
import os
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    pkg_share = get_package_share_directory('my_robot')

    urdf_file = os.path.join(pkg_share, 'urdf', 'my_robot.urdf.xacro')

    # Robot State Publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'robot_description': urdf_file}],
        output='screen'
    )

    # Gazebo launch
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('ros_gz_sim'),
                'launch',
                'gz_sim.launch.py'
            ])
        ]),
        launch_arguments={'gz_args': '-r empty.sdf'}.items()
    )

    # Spawn robot
    spawn_robot = Node(
        package='ros_gz_sim',
        executable='create',
        arguments=[
            '-name', 'my_robot',
            '-topic', 'robot_description',
            '-x', '0.0',
            '-y', '0.0',
            '-z', '0.5'
        ],
        output='screen'
    )

    return LaunchDescription([
        robot_state_publisher,
        gazebo,
        spawn_robot
    ])
```

#### 2.4 Build and Test

```bash
cd ~/ros2_ws
colcon build --packages-select my_robot
source install/setup.bash

# Launch robot in Gazebo
ros2 launch my_robot robot.launch.py

# Test teleoperation (in new terminal)
ros2 run teleop_twist_keyboard teleop_twist_keyboard
```

---

### Step 3: Sensor Integration

#### 3.1 Add LiDAR Sensor to URDF

Add to `urdf/my_robot.urdf.xacro` before `</robot>`:

```xml
  <!-- LiDAR Link -->
  <link name="lidar_link">
    <visual>
      <geometry>
        <cylinder radius="0.05" length="0.04"/>
      </geometry>
      <material name="red">
        <color rgba="0.8 0.0 0.0 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.05" length="0.04"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.2"/>
      <inertia ixx="0.000167" ixy="0.0" ixz="0.0"
               iyy="0.000167" iyz="0.0" izz="0.00025"/>
    </inertial>
  </link>

  <joint name="lidar_joint" type="fixed">
    <parent link="base_link"/>
    <child link="lidar_link"/>
    <origin xyz="0.15 0 0.1" rpy="0 0 0"/>
  </joint>

  <!-- LiDAR Gazebo Plugin -->
  <gazebo reference="lidar_link">
    <sensor name="lidar" type="gpu_lidar">
      <topic>/scan</topic>
      <update_rate>10</update_rate>
      <lidar>
        <scan>
          <horizontal>
            <samples>360</samples>
            <resolution>1.0</resolution>
            <min_angle>-3.14159</min_angle>
            <max_angle>3.14159</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.12</min>
          <max>10.0</max>
          <resolution>0.01</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>0.01</stddev>
        </noise>
      </lidar>
      <always_on>1</always_on>
      <visualize>true</visualize>
    </sensor>
  </gazebo>
```

#### 3.2 Add IMU Sensor

Add to URDF:

```xml
  <!-- IMU Link -->
  <link name="imu_link">
    <inertial>
      <mass value="0.01"/>
      <inertia ixx="0.00001" ixy="0.0" ixz="0.0"
               iyy="0.00001" iyz="0.0" izz="0.00001"/>
    </inertial>
  </link>

  <joint name="imu_joint" type="fixed">
    <parent link="base_link"/>
    <child link="imu_link"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </joint>

  <!-- IMU Gazebo Plugin -->
  <gazebo reference="imu_link">
    <sensor name="imu_sensor" type="imu">
      <topic>/imu</topic>
      <update_rate>100</update_rate>
      <imu>
        <angular_velocity>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.01</stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.01</stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.01</stddev>
            </noise>
          </z>
        </angular_velocity>
        <linear_acceleration>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.1</stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.1</stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.1</stddev>
            </noise>
          </z>
        </linear_acceleration>
      </imu>
      <always_on>1</always_on>
    </sensor>
  </gazebo>
```

#### 3.3 Visualize Sensors in RViz2

Create `config/rviz_config.rviz` and add to launch file:

```python
# Add to robot.launch.py
rviz = Node(
    package='rviz2',
    executable='rviz2',
    name='rviz2',
    arguments=['-d', os.path.join(pkg_share, 'config', 'rviz_config.rviz')],
    output='screen'
)
```

```bash
# Rebuild and test
colcon build --packages-select my_robot
source install/setup.bash
ros2 launch my_robot robot.launch.py

# In new terminal, view topics
ros2 topic list
ros2 topic echo /scan
ros2 topic echo /imu
```

---

### Step 4: Navigation Implementation

#### 4.1 Create Obstacle Avoidance Node

Create `src/obstacle_avoidance.cpp`:

```cpp
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"
#include "geometry_msgs/msg/twist.hpp"
#include <algorithm>

class ObstacleAvoidance : public rclcpp::Node
{
public:
  ObstacleAvoidance() : Node("obstacle_avoidance")
  {
    scan_sub_ = this->create_subscription<sensor_msgs::msg::LaserScan>(
      "/scan", 10,
      std::bind(&ObstacleAvoidance::scan_callback, this, std::placeholders::_1));

    cmd_pub_ = this->create_publisher<geometry_msgs::msg::Twist>("/cmd_vel", 10);

    timer_ = this->create_wall_timer(
      std::chrono::milliseconds(100),
      std::bind(&ObstacleAvoidance::control_loop, this));

    RCLCPP_INFO(this->get_logger(), "Obstacle avoidance node started");
  }

private:
  void scan_callback(const sensor_msgs::msg::LaserScan::SharedPtr msg)
  {
    latest_scan_ = msg;
  }

  void control_loop()
  {
    if (!latest_scan_) return;

    auto cmd = geometry_msgs::msg::Twist();

    // Find minimum distance in front (30 degrees each side)
    size_t total_samples = latest_scan_->ranges.size();
    size_t front_samples = total_samples / 12;  // ~30 degrees

    float min_front_dist = std::numeric_limits<float>::max();

    for (size_t i = 0; i < front_samples; ++i) {
      min_front_dist = std::min(min_front_dist, latest_scan_->ranges[i]);
      min_front_dist = std::min(min_front_dist,
                                 latest_scan_->ranges[total_samples - 1 - i]);
    }

    // Simple obstacle avoidance logic
    const float SAFE_DISTANCE = 0.5;  // meters
    const float LINEAR_SPEED = 0.3;
    const float ANGULAR_SPEED = 0.5;

    if (min_front_dist > SAFE_DISTANCE) {
      // Clear ahead, move forward
      cmd.linear.x = LINEAR_SPEED;
      cmd.angular.z = 0.0;
    } else {
      // Obstacle detected, turn
      cmd.linear.x = 0.0;
      cmd.angular.z = ANGULAR_SPEED;
      RCLCPP_WARN(this->get_logger(), "Obstacle at %.2fm, turning", min_front_dist);
    }

    cmd_pub_->publish(cmd);
  }

  rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr scan_sub_;
  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr cmd_pub_;
  rclcpp::TimerBase::SharedPtr timer_;
  sensor_msgs::msg::LaserScan::SharedPtr latest_scan_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<ObstacleAvoidance>());
  rclcpp::shutdown();
  return 0;
}
```

#### 4.2 Update CMakeLists.txt

Add to `CMakeLists.txt`:

```cmake
add_executable(obstacle_avoidance src/obstacle_avoidance.cpp)
ament_target_dependencies(obstacle_avoidance
  rclcpp
  sensor_msgs
  geometry_msgs
)

install(TARGETS
  obstacle_avoidance
  DESTINATION lib/${PROJECT_NAME}
)
```

#### 4.3 Create Test World with Obstacles

Create `worlds/obstacles.sdf`:

```xml
<?xml version="1.0"?>
<sdf version="1.9">
  <world name="obstacle_world">
    <physics name="1ms" type="ignore">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
    </physics>

    <plugin filename="gz-sim-physics-system" name="gz::sim::systems::Physics"/>
    <plugin filename="gz-sim-sensors-system" name="gz::sim::systems::Sensors"/>
    <plugin filename="gz-sim-scene-broadcaster-system"
            name="gz::sim::systems::SceneBroadcaster"/>

    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
            </plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
          </material>
        </visual>
      </link>
    </model>

    <!-- Add obstacles -->
    <include>
      <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/Construction Barrel</uri>
      <pose>2 0 0 0 0 0</pose>
    </include>

    <include>
      <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/Construction Barrel</uri>
      <pose>1 2 0 0 0 0</pose>
    </include>

    <include>
      <uri>https://fuel.gazebosim.org/1.0/OpenRobotics/models/Construction Barrel</uri>
      <pose>-1 -2 0 0 0 0</pose>
    </include>

  </world>
</sdf>
```

#### 4.4 Test Navigation

```bash
colcon build --packages-select my_robot
source install/setup.bash

# Launch with obstacle world
ros2 launch my_robot robot.launch.py world:=obstacles.sdf

# Run obstacle avoidance
ros2 run my_robot obstacle_avoidance
```

---

### Step 5: Testing and Validation

#### 5.1 Create Test Script

Create `test/test_robot.py`:

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
import time

class RobotTester(Node):
    def __init__(self):
        super().__init__('robot_tester')

        # Subscribers
        self.scan_sub = self.create_subscription(
            LaserScan, '/scan', self.scan_callback, 10)
        self.odom_sub = self.create_subscription(
            Odometry, '/odom', self.odom_callback, 10)

        # Publisher
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        self.scan_received = False
        self.odom_received = False

    def scan_callback(self, msg):
        self.scan_received = True
        self.get_logger().info(f'LiDAR: {len(msg.ranges)} points, '
                              f'min range: {min(msg.ranges):.2f}m')

    def odom_callback(self, msg):
        self.odom_received = True
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        self.get_logger().info(f'Odometry: x={x:.2f}, y={y:.2f}')

    def test_sensors(self):
        """Test if sensors are publishing"""
        self.get_logger().info('Testing sensors...')
        rclpy.spin_once(self, timeout_sec=2.0)

        assert self.scan_received, "LiDAR not publishing"
        assert self.odom_received, "Odometry not publishing"
        self.get_logger().info('✓ All sensors working')

    def test_movement(self):
        """Test robot movement"""
        self.get_logger().info('Testing movement...')

        cmd = Twist()
        cmd.linear.x = 0.2

        for _ in range(10):
            self.cmd_pub.publish(cmd)
            time.sleep(0.1)

        cmd.linear.x = 0.0
        self.cmd_pub.publish(cmd)
        self.get_logger().info('✓ Movement test complete')

def main():
    rclpy.init()
    tester = RobotTester()

    try:
        tester.test_sensors()
        tester.test_movement()
        tester.get_logger().info('All tests passed!')
    except AssertionError as e:
        tester.get_logger().error(f'Test failed: {e}')
    finally:
        tester.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### 5.2 Performance Metrics

Create performance logging:

```python
# Create metrics/performance_logger.py
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
import csv
import time

class PerformanceLogger(Node):
    def __init__(self):
        super().__init__('performance_logger')

        self.scan_sub = self.create_subscription(
            LaserScan, '/scan', self.scan_callback, 10)
        self.cmd_sub = self.create_subscription(
            Twist, '/cmd_vel', self.cmd_callback, 10)

        self.log_file = open('performance_log.csv', 'w')
        self.writer = csv.writer(self.log_file)
        self.writer.writerow(['Timestamp', 'Min Distance', 'Linear Vel', 'Angular Vel'])

        self.min_distance = 0.0
        self.linear_vel = 0.0
        self.angular_vel = 0.0

        self.timer = self.create_timer(0.1, self.log_data)

    def scan_callback(self, msg):
        self.min_distance = min(msg.ranges)

    def cmd_callback(self, msg):
        self.linear_vel = msg.linear.x
        self.angular_vel = msg.angular.z

    def log_data(self):
        self.writer.writerow([
            time.time(),
            self.min_distance,
            self.linear_vel,
            self.angular_vel
        ])

    def __del__(self):
        self.log_file.close()

def main():
    rclpy.init()
    logger = PerformanceLogger()
    rclpy.spin(logger)

if __name__ == '__main__':
    main()
```

#### 5.3 Run Full Test Suite

```bash
# Build with tests
colcon build --packages-select my_robot
source install/setup.bash

# Launch robot
ros2 launch my_robot robot.launch.py &

# Run tests
ros2 run my_robot test_robot

# Log performance
ros2 run my_robot performance_logger

# Visualize results
python3 -c "
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('performance_log.csv')
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))

ax1.plot(df['Timestamp'], df['Min Distance'])
ax1.set_ylabel('Min Distance (m)')
ax1.set_title('Obstacle Detection Over Time')

ax2.plot(df['Timestamp'], df['Linear Vel'], label='Linear')
ax2.plot(df['Timestamp'], df['Angular Vel'], label='Angular')
ax2.set_ylabel('Velocity')
ax2.set_xlabel('Time (s)')
ax2.set_title('Robot Velocity Commands')
ax2.legend()

plt.tight_layout()
plt.savefig('performance_analysis.png')
print('Performance analysis saved to performance_analysis.png')
"
```

## Expected Outcomes

After completing this project, you'll have:
- A functional mobile robot simulation
- Understanding of ROS 2 package structure
- Experience with URDF robot modeling
- Practical sensor integration skills
- Basic navigation algorithm implementation

## Next Steps

Once you've completed this project, you can:
- Enhance the robot with additional sensors (cameras, ultrasonic)
- Implement SLAM (Simultaneous Localization and Mapping)
- Add autonomous goal-seeking behavior
- Proceed to **Project 2: Humanoid Robot Simulation** to work with bipedal robots

## Resources

- [ROS 2 Documentation](https://docs.ros.org/en/jazzy/)
- [Gazebo Tutorials](https://gazebosim.org/docs)
- [Appendix A: ROS 2 Commands](/docs/appendices/appendix-a-ros2-commands)
