---
id: ch06-ros2-concepts
title: Chapter 6 - ROS 2 Core Concepts
description: Master nodes, topics, services, actions, parameters, and the ROS 2 computational graph.
sidebar_label: Ch 6. ROS 2 Concepts
sidebar_position: 2
keywords: [nodes, topics, services, actions, parameters, computational graph]
difficulty: intermediate
estimatedReadingTime: 30
---

# Chapter 6: ROS 2 Core Concepts

## Learning Objectives

By the end of this chapter, you will be able to:
- Create and manage ROS 2 nodes
- Publish and subscribe to topics
- Implement services and actions
- Configure parameters and launch files

## Introduction

ROS 2 (Robot Operating System 2) is built around a distributed architecture where computational processes, called nodes, communicate through a flexible messaging system. Understanding the core concepts of ROS 2 is essential for building robust robotic systems, from simple wheeled robots to complex humanoid platforms.

In this chapter, we'll explore the fundamental building blocks of ROS 2: nodes, topics, services, actions, and parameters. These concepts form the foundation of robot communication and coordination. By mastering these concepts, you'll be able to design modular, scalable robotic systems that can handle everything from sensor data processing to complex motion control.

:::info Prerequisites
Before diving into this chapter, ensure you have:
- ROS 2 installed (Humble or newer recommended)
- Basic Python or C++ programming knowledge
- Completed the ROS 2 installation from Chapter 5
:::

## ROS 2 Nodes

### What is a Node?

A node is an executable process that performs computation. In ROS 2, robotics applications are composed of multiple nodes working together. Each node should have a single, well-defined purpose. For example, you might have:

- One node for controlling motor drivers
- Another node for processing camera images
- A third node for path planning
- A fourth node for decision making

This modular approach makes your code more maintainable, testable, and reusable.

### Node Lifecycle

ROS 2 introduces managed nodes with a defined lifecycle that allows for better control over node states. The lifecycle states include:

1. **Unconfigured**: Initial state after creation
2. **Inactive**: Configured but not running
3. **Active**: Fully operational
4. **Finalized**: Shutdown state

Understanding lifecycle nodes is crucial for building robust systems that can handle failures gracefully.

### Creating Your First Node

Let's create a simple node in Python:

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Minimal node has been started')

        # Create a timer that calls a callback every second
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.counter = 0

    def timer_callback(self):
        self.counter += 1
        self.get_logger().info(f'Timer callback executed {self.counter} times')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

And the equivalent in C++:

```cpp
#include <chrono>
#include <memory>
#include "rclcpp/rclcpp.hpp"

using namespace std::chrono_literals;

class MinimalNode : public rclcpp::Node
{
public:
    MinimalNode() : Node("minimal_node"), counter_(0)
    {
        RCLCPP_INFO(this->get_logger(), "Minimal node has been started");

        // Create a timer that calls a callback every second
        timer_ = this->create_wall_timer(
            1s, std::bind(&MinimalNode::timer_callback, this));
    }

private:
    void timer_callback()
    {
        counter_++;
        RCLCPP_INFO(this->get_logger(), "Timer callback executed %d times", counter_);
    }

    rclcpp::TimerBase::SharedPtr timer_;
    int counter_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<MinimalNode>());
    rclcpp::shutdown();
    return 0;
}
```

:::tip Best Practice
Always give your nodes descriptive names. Use namespaces to organize nodes in complex systems. For example: `/arm/joint_controller` or `/perception/camera_processor`.
:::

## Topics: Publisher-Subscriber Pattern

### Understanding Topics

Topics are named channels over which nodes exchange messages. They implement the publish-subscribe pattern, where:

- **Publishers** send (publish) messages to topics
- **Subscribers** receive (subscribe to) messages from topics
- Multiple nodes can publish to the same topic
- Multiple nodes can subscribe to the same topic

This decoupling allows for flexible system architectures.

### Message Types

ROS 2 uses predefined message types from packages like `std_msgs`, `geometry_msgs`, `sensor_msgs`, etc. You can also create custom message types.

Common message types include:
- `std_msgs/String`: Simple text messages
- `geometry_msgs/Twist`: Velocity commands (linear and angular)
- `sensor_msgs/Image`: Camera images
- `sensor_msgs/JointState`: Robot joint positions and velocities

### Creating a Publisher

Here's a publisher that sends velocity commands:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

class VelocityPublisher(Node):
    def __init__(self):
        super().__init__('velocity_publisher')

        # Create publisher on 'cmd_vel' topic with queue size 10
        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)

        # Publish at 10 Hz
        self.timer = self.create_timer(0.1, self.publish_velocity)
        self.get_logger().info('Velocity publisher started')

    def publish_velocity(self):
        msg = Twist()
        msg.linear.x = 0.5  # Move forward at 0.5 m/s
        msg.angular.z = 0.1  # Turn at 0.1 rad/s

        self.publisher_.publish(msg)
        self.get_logger().debug('Published velocity command')

def main(args=None):
    rclpy.init(args=args)
    node = VelocityPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Creating a Subscriber

And here's a corresponding subscriber:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

class VelocitySubscriber(Node):
    def __init__(self):
        super().__init__('velocity_subscriber')

        # Create subscription to 'cmd_vel' topic
        self.subscription = self.create_subscription(
            Twist,
            'cmd_vel',
            self.velocity_callback,
            10)
        self.get_logger().info('Velocity subscriber started')

    def velocity_callback(self, msg):
        self.get_logger().info(
            f'Received: linear={msg.linear.x:.2f}, angular={msg.angular.z:.2f}')

def main(args=None):
    rclpy.init(args=args)
    node = VelocitySubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Quality of Service (QoS)

QoS policies control how messages are delivered. Key QoS settings include:

- **Reliability**: Best effort vs. reliable delivery
- **Durability**: Transient local (keep last message) vs. volatile
- **History**: Keep last N messages or all messages
- **Depth**: Queue size for history

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

# Create custom QoS profile
qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)

# Use it when creating publisher/subscriber
self.publisher_ = self.create_publisher(Twist, 'cmd_vel', qos_profile)
```

:::warning QoS Compatibility
Publishers and subscribers must have compatible QoS settings to communicate. Mismatched QoS is a common source of communication failures.
:::

## Services: Request-Response Pattern

### Understanding Services

While topics are for continuous data streams, services implement request-response communication. Services are used when you need:

- Synchronous communication (wait for response)
- Infrequent operations (like triggering a calibration)
- Request-reply semantics

A service consists of:
- **Service server**: Provides the service
- **Service client**: Requests the service

### Service Types

Service definitions have two parts:
- Request message
- Response message

For example, `AddTwoInts.srv`:
```
int64 a
int64 b
---
int64 sum
```

### Creating a Service Server

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class AdditionServer(Node):
    def __init__(self):
        super().__init__('addition_server')

        # Create service
        self.srv = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_two_ints_callback)

        self.get_logger().info('Addition service ready')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(
            f'Incoming request: {request.a} + {request.b} = {response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    node = AdditionServer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Creating a Service Client

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class AdditionClient(Node):
    def __init__(self):
        super().__init__('addition_client')

        # Create client
        self.client = self.create_client(AddTwoInts, 'add_two_ints')

        # Wait for service to be available
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting...')

    def send_request(self, a, b):
        request = AddTwoInts.Request()
        request.a = a
        request.b = b

        # Call service asynchronously
        future = self.client.call_async(request)
        return future

def main(args=None):
    rclpy.init(args=args)
    node = AdditionClient()

    # Send request
    future = node.send_request(10, 20)

    # Wait for response
    rclpy.spin_until_future_complete(node, future)

    if future.result() is not None:
        node.get_logger().info(f'Result: {future.result().sum}')
    else:
        node.get_logger().error('Service call failed')

    node.destroy_node()
    rclpy.shutdown()
```

## Actions: Long-Running Tasks

### Understanding Actions

Actions are for tasks that:
- Take significant time to complete
- Need to provide feedback during execution
- Can be cancelled mid-execution

Examples include:
- Navigation to a goal position
- Executing a complex motion sequence
- Grasping an object

Actions have three components:
- **Goal**: What to accomplish
- **Feedback**: Progress updates
- **Result**: Final outcome

### Action Definition Example

```
# Goal
geometry_msgs/PoseStamped target_pose
---
# Result
bool success
string message
---
# Feedback
geometry_msgs/PoseStamped current_pose
float32 distance_remaining
```

### Creating an Action Server

```python
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from action_tutorials_interfaces.action import Fibonacci
import time

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')

        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

        self.get_logger().info('Fibonacci action server started')

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        # Generate Fibonacci sequence
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            # Check if goal was cancelled
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            # Calculate next number
            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])

            # Publish feedback
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(0.5)

        # Mark goal as succeeded
        goal_handle.succeed()

        # Return result
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        return result

def main(args=None):
    rclpy.init(args=args)
    node = FibonacciActionServer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Creating an Action Client

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from action_tutorials_interfaces.action import Fibonacci

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

    def send_goal(self, order):
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        # Wait for action server
        self._action_client.wait_for_server()

        # Send goal with feedback callback
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Feedback: {feedback.sequence}')

    def goal_response_callback(self, future):
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')

        # Get result
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: {result.sequence}')

def main(args=None):
    rclpy.init(args=args)
    node = FibonacciActionClient()
    node.send_goal(10)
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

:::tip When to Use Actions vs Services
Use **services** for quick operations (< 1 second). Use **actions** for long-running tasks that need feedback or cancellation capability.
:::

## Parameters: Dynamic Configuration

### Understanding Parameters

Parameters allow you to configure nodes at runtime without recompiling code. They're useful for:

- Tuning control gains
- Setting sensor configurations
- Adjusting algorithm parameters

### Declaring and Using Parameters

```python
import rclpy
from rclpy.node import Node

class ParameterNode(Node):
    def __init__(self):
        super().__init__('parameter_node')

        # Declare parameters with default values
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('robot_name', 'my_robot')
        self.declare_parameter('enable_safety', True)

        # Get parameter values
        self.max_velocity = self.get_parameter('max_velocity').value
        self.robot_name = self.get_parameter('robot_name').value
        self.enable_safety = self.get_parameter('enable_safety').value

        self.get_logger().info(f'Max velocity: {self.max_velocity}')
        self.get_logger().info(f'Robot name: {self.robot_name}')
        self.get_logger().info(f'Safety enabled: {self.enable_safety}')

        # Add callback for parameter changes
        self.add_on_set_parameters_callback(self.parameter_callback)

    def parameter_callback(self, params):
        for param in params:
            if param.name == 'max_velocity':
                self.max_velocity = param.value
                self.get_logger().info(f'Updated max_velocity to {param.value}')

        return rclpy.parameter.SetParametersResult(successful=True)

def main(args=None):
    rclpy.init(args=args)
    node = ParameterNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Setting Parameters from Command Line

```bash
# Launch with parameters
ros2 run my_package parameter_node --ros-args -p max_velocity:=2.0 -p robot_name:=atlas

# Set parameter at runtime
ros2 param set /parameter_node max_velocity 3.0

# Get parameter value
ros2 param get /parameter_node max_velocity

# List all parameters
ros2 param list
```

### Parameter Files (YAML)

```yaml
# config/params.yaml
parameter_node:
  ros__parameters:
    max_velocity: 1.5
    robot_name: "humanoid_01"
    enable_safety: true
```

Load with:
```bash
ros2 run my_package parameter_node --ros-args --params-file config/params.yaml
```

## The Computational Graph

### Visualizing Your System

ROS 2 creates a computational graph where nodes are vertices and communication channels are edges. Understanding this graph is crucial for debugging and system design.

### Using rqt_graph

```bash
# Install rqt tools
sudo apt install ros-humble-rqt-graph

# Launch graph visualization
rqt_graph
```

This shows you:
- All active nodes
- Topics being published/subscribed
- Communication patterns

### Introspection Commands

```bash
# List all nodes
ros2 node list

# Get node information
ros2 node info /my_node

# List all topics
ros2 topic list

# See topic details
ros2 topic info /cmd_vel

# Echo topic messages
ros2 topic echo /cmd_vel

# Check topic publish rate
ros2 topic hz /cmd_vel

# List all services
ros2 service list

# Call a service
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 10, b: 20}"

# List all actions
ros2 action list

# Send action goal
ros2 action send_goal /fibonacci action_tutorials_interfaces/action/Fibonacci "{order: 5}"
```

## Best Practices

### Node Design

1. **Single Responsibility**: Each node should do one thing well
2. **Descriptive Naming**: Use clear, hierarchical names
3. **Error Handling**: Always handle exceptions and edge cases
4. **Logging**: Use appropriate log levels (DEBUG, INFO, WARN, ERROR, FATAL)

```python
# Good logging example
self.get_logger().debug('Detailed debug information')
self.get_logger().info('Normal operation message')
self.get_logger().warn('Something unexpected happened')
self.get_logger().error('Error occurred, but node can continue')
self.get_logger().fatal('Critical error, node cannot continue')
```

### Communication Patterns

1. **Choose the Right Tool**:
   - Continuous data → Topics
   - Quick request-response → Services
   - Long-running tasks → Actions

2. **QoS Settings**: Match QoS to your requirements
   - Sensor data: Best effort, volatile
   - Commands: Reliable, transient local

3. **Message Design**: Keep messages focused and efficient

### Performance Considerations

1. **Callback Duration**: Keep callbacks short (< 10ms if possible)
2. **Queue Sizes**: Balance between memory usage and message loss
3. **Timer Frequencies**: Don't poll faster than necessary
4. **Threading**: Use executors for concurrent callbacks when needed

```python
from rclpy.executors import MultiThreadedExecutor

executor = MultiThreadedExecutor()
executor.add_node(node1)
executor.add_node(node2)
executor.spin()
```

## Common Pitfalls

### 1. QoS Mismatch

**Problem**: Publisher and subscriber have incompatible QoS settings

**Solution**: Ensure QoS policies are compatible. Use `ros2 topic info -v` to check QoS settings.

### 2. Callback Blocking

**Problem**: Long-running callbacks block other operations

**Solution**: Offload heavy computation to separate threads or use asynchronous patterns.

```python
import threading

def heavy_computation(self, data):
    # Long-running task
    result = process_data(data)
    return result

def callback(self, msg):
    # Offload to thread
    thread = threading.Thread(target=self.heavy_computation, args=(msg.data,))
    thread.start()
```

### 3. Resource Leaks

**Problem**: Not properly cleaning up nodes, publishers, subscriptions

**Solution**: Always destroy nodes and shutdown rclpy properly, use context managers when possible.

### 4. Namespace Confusion

**Problem**: Nodes and topics not in expected namespaces

**Solution**: Use launch files to organize namespaces consistently.

## Practical Exercise

### Build a Multi-Node System

Create a simple robotic system with three nodes:

1. **Sensor Node**: Publishes simulated sensor data (e.g., distance readings)
2. **Processing Node**: Subscribes to sensor data, processes it, and publishes results
3. **Control Node**: Subscribes to processed data and publishes control commands

**Requirements**:
- Use appropriate message types
- Implement proper error handling
- Add parameters for configuration
- Use rqt_graph to visualize your system

**Extension**: Add a service to trigger sensor calibration and an action for a complex control sequence.

## Further Reading

- [ROS 2 Documentation](https://docs.ros.org/en/humble/): Official ROS 2 documentation
- [ROS 2 Design](https://design.ros2.org/): Detailed design documents
- [ROS 2 Tutorials](https://docs.ros.org/en/humble/Tutorials.html): Step-by-step tutorials
- DDS Specification: Understanding the underlying middleware

## Cross-References

- **Chapter 5**: ROS 2 installation and workspace setup
- **Chapter 7**: Deep dive into communication patterns and DDS
- **Chapter 8**: Applying these concepts to humanoid robot control
- **Chapter 9**: Launch files for managing complex node systems

## Next Steps

Now that you understand ROS 2 core concepts, you're ready to:

1. Explore advanced communication patterns in Chapter 7
2. Learn about launch files and workspace organization
3. Apply these concepts to real robot hardware
4. Build your first complete robotic application

In the next chapter, we'll dive deeper into communication patterns, exploring QoS policies, custom messages, and multi-node architectures in detail.

:::tip Practice Makes Perfect
The best way to learn ROS 2 is by building. Start with simple nodes and gradually increase complexity. Use the introspection tools frequently to understand what's happening in your system.
:::
